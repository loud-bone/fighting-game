<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fighting Game Prototype</title>
	<link rel="icon" href="data:,">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            background: #000000;
            font-family: "Arial Black", sans-serif;
            overflow-x: hidden;
            padding-top: 10px;
            padding-bottom: 20px;
        }
		
		#bgContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
        }

        #fgContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 1024px;
            height: 576px;
            z-index: 15;
            overflow: visible;
            pointer-events: none;
        }
		
        #bgVideo {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 1920px;
            height: 1080px;
            transform-origin: center center;
            object-fit: cover;
        }
        
        #bgForeground {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 1920px;
            height: 1080px;
            transform-origin: center center;
            object-fit: cover;
            pointer-events: none;
        }
        
        /* Zoom animation for intro sequence */
        .bg-zoom-in {
            animation: zoomToCanvas 5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }
        
        .fg-zoom-in {
            animation: zoomToCanvasForeground 5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }
        
        @keyframes zoomToCanvas {
            from {
                transform: translate(-50%, -59%) scale(0.56);  /* Start showing full 1920 width */
            }
            to {
                transform: translate(-50%, -65%) scale(.8);  /* Zoom in to 1:1 */
            }
        }
        
        @keyframes zoomToCanvasForeground {
            from {
                transform: translate(-50%, -59%) scale(0.56);  /* Start slightly wider for parallax */
            }
            to {
                transform: translate(-50%, -65%) scale(1.2);  /* Zoom faster than background */
            }
        }
        
        .game-container {
			position: relative;
			width: 100%;
			max-width: 1080px;
			margin: 0 auto;
			display: none; /* Hidden until game starts */
			z-index: 10;  /* Above background */
        }
        
        #gameCanvas {
            border: 5px solid #ff0000;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            background: transparent;
            width: 100%;
            height: auto;
            display: block;
        }
        
        .mode-buttons {
            position: fixed;
            top: 80%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 999;
        }
        
        .mode-buttons img:active {
            transform: scale(0.95);
        }
        
        .mode-buttons.hidden {
            display: none;
        }

		#startVideo {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			object-fit: cover;
			z-index: 17;
		}
        
        .ui-container {
            position: absolute;
            top: 10px;
            left: 0;
            right: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
			z-index: 20;
        }
        
        .player-hud {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .player-name {
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .health-bar-container {
            width: 300px;
            height: 30px;
            background: #333;
            border: 2px solid #fff;
            border-radius: 5px;
            overflow: visible;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
			position: relative;
        }

		.health-bar-container::after {
			content: '';
			position: absolute;
			top: -10px;
			left: -10px;
			right: -10px;
			bottom: -10px;
			background: url('images/bar.png') no-repeat center center;
			background-size: contain;
			pointer-events: none;
			z-index: 10;
		}
        
        .health-bar {
            height: 100%;
            background: linear-gradient(to bottom, #4CAF50 0%, #45a049 100%);
            transition: width 0.3s ease;
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
        }
        
        .health-bar.low {
            background: linear-gradient(to bottom, #ff9800 0%, #ff6f00 100%);
        }
        
        .health-bar.critical {
            background: linear-gradient(to bottom, #f44336 0%, #d32f2f 100%);
            animation: pulse 0.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

		.round-wins {
			display: flex;
			gap: 5px;
			margin-top: 5px;
			justify-content: center;
		}

		.win-coin {
			width: 40px;
			height: 40px;
			object-fit: contain;
		}

        
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            color: #FFD700;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.9);
            display: none;
            animation: fadeIn 0.75s;
			z-index: 10000;
        }
		
        #frameMask {
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-55%, -50%);
            width: 2400px;  /* Large enough to cover max zoom */
            height: 1400px;
            z-index: 16; /* above foreground */
            pointer-events: none;
        }
        
        #frameMask img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

		#announcementImage {
			position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            height: auto;
            object-fit: contain;
            z-index: 10001;
		}
		
		@keyframes announcementZoom {
			//* Frames 1-5: Zoom in (0-10.4%) *//
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            10.4% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            
            /* Frames 6-45: Hold at full size (10.4-93.75%) */
            93.75% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            
            /* Frames 46-49: Zoom out (93.75-100%) */
            95.8% { transform: translate(-50%, -50%) scale(0.75); opacity: 1; }
            97.9% { transform: translate(-50%, -50%) scale(0.5); opacity: 0.8; }
            99% { transform: translate(-50%, -50%) scale(0.25); opacity: 0.5; }
            100% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
        }
        
        .announcement-animate {
            animation: announcementZoom 2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }
		

		#vsOverlay {
    		position: fixed;
    		top: 0;
    		left: 0;
    		width: 100vw;
    		height: 100vh;
    		background: #000000;
    		z-index: 9999;
    		display: flex;
    		justify-content: center;
    		align-items: center;
		}

		#finisherOverlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background: rgba(0, 0, 0, 0.7);
			z-index: 10000;
			display: flex;
			justify-content: center;
			align-items: center;
		}

		#finisherContent {
			font-size: 72px;
			color: #ff0000;
			text-shadow: 6px 6px 12px rgba(255,0,0,0.8);
			margin-bottom: 50px;
		}

		.finisher-options {
			display: flex;
			gap: 50px;
			justify-content: center;
			margin: 50px 0;
		}

		.finisher-option {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 20px;
			padding: 30px;
			background: rgba(255,255,255,0.1);
			border: 3px solid #FFD700;
			border-radius: 10px;
			cursor: pointer;
			transition: all 0.3s;
		}

		.finisher-option:hover {
			background: rgba(255,215,0,0.2);
			transform: scale(1.05);
		}
		
		.finisher-option .key {
			font-size: 48px;
			color: #FFD700;
			font-weight: bold;
		}

		.finisher-option .name {
			font-size: 24px;
			color: white;
		}

		#pauseOverlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background: rgba(0, 0, 0, 0.95);
			z-index: 10000;
			display: flex;
			justify-content: center;
			align-items: center;
		}
		
		#pauseContent {
			text-align: center;
			color: white;
			font-family: 'Arial Black', sans-serif;
		}
		
		#pauseContent h1 {
			font-size: 96px;
			color: #FFD700;
			text-shadow: 6px 6px 12px rgba(255,215,0,0.8);
			margin-bottom: 30px;
		}
		
		#pauseContent p {
			font-size: 24px;
			color: #aaa;
			margin-bottom: 50px;
		}
		
		#pauseContent img {
			display: block;
			width: 300px;
			height: auto;
			margin: 20px auto;
			cursor: pointer;
			transition: transform 0.2s;
		}
		
		#pauseContent img:hover {
			transform: scale(1.05);
		}
		
		#pauseContent img:active {
			transform: scale(0.95);
		}
		
		@keyframes pulse {
			0%, 100% { opacity: 1; transform: scale(1); }
			50% { opacity: 0.7; transform: scale(1.1); }
		}

		#vsContent {
   			text-align: center;
    		color: white;
    		font-family: 'Arial Black', sans-serif;
		}

		#vsContent .character-name {
    		font-size: 64px;
    		color: #FFD700;
    		text-shadow: 4px 4px 8px rgba(0,0,0,0.9);
    		margin: 20px 0;
		}

		#vsContent .vs-text {
    		font-size: 96px;
    		color: #ff0000;
    		text-shadow: 6px 6px 12px rgba(255,0,0,0.8);
    		margin: 40px 0;
    		font-weight: bold;
		}
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        

    </style>
</head>
<body>
	<!-- Background video container (hidden until game starts) -->
	<div id="bgContainer" style="display: none;">
		<video id="bgVideo" playsinline>
			<source src="" type="video/mp4">
        </video>
    </div>
	
    <video id="startVideo" autoplay loop muted playsinline style="display: none;">
        <source src="videos/title.loop.mp4" type="video/mp4">
    </video>
	
    <div class="mode-buttons" id="modeButtons">
        <img id="btnSinglePlayer" src="images/start-1.png" alt="Start Game" style="cursor: pointer; width: 400px; height: auto;">
    </div>
    	    <!-- Foreground on separate layer -->
    <div id="fgContainer" style="display: none;">
        <img id="bgForeground" style="display: none;">
    </div>
	
    <div class="game-container">
        <canvas id="gameCanvas" width="1024" height="576"></canvas>
        <div class="ui-container">
            <div class="player-hud">
                <div class="player-name">PLAYER 1</div>
                <div class="health-bar-container">
                    <div class="health-bar" id="player1Health"></div>
                </div>
				<div class="round-wins" id="player1Wins"></div>
            </div>
            <div class="player-hud" style="align-items: flex-end;">
                <div class="player-name">PLAYER 2</div>
                <div class="health-bar-container">
                    <div class="health-bar" id="player2Health"></div>
                </div>
				<div class="round-wins" id="player2Wins"></div>
            </div>
        </div>

        <div class="game-over" id="gameOver"></div>
    </div>
	
	<!-- Frame mask to hide overflow -->
    <div id="frameMask">
        <img src="images/frame-mask.png" alt="">
    </div>
	
	<!-- Announcement animation overlay -->
	<img id="announcementImage" style="display: none;">
	
	<div id="vsOverlay" style="display: none;">
		<div id="vsContent"></div>
	</div>
	
	<div id="finisherOverlay" style="display: none;"></div>
    
    <!-- NEW: Pause menu -->
    <div id="pauseOverlay" style="display: none;">
        <div id="pauseContent">
            <h1>PAUSED</h1>
            <p>Press ESC to Resume</p>
            <img id="resumeBtn" src="images/button-resume.png" alt="Resume" style="cursor: pointer;">
            <img id="restartBtn" src="images/button-restart.png" alt="Restart Fight" style="cursor: pointer;">
            <img id="quitBtn" src="images/button-quit.png" alt="Quit" style="cursor: pointer;">
        </div>
	</div>
    
    <div class="controls-image">
        <img src="images/controls.png" alt="Game Controls" style="width: 100%; max-width: 600px; display: block; margin: 20px auto;">
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const GRAVITY = 0.8;
        const GROUND = canvas.height - 100;
        
        // Game state
        let gameOver = false;
		let gameInCombat = false;			// Controls whether fighters can move/attack
        let currentFight = 1;				// Track which enemy (1-6 or boss)
		let currentRound = 1; 				// the round we are at
		let player1RoundWins = 0; 
		let player2RoundWins = 0;
		let inFinisher = false;				// NEW: Are we in finisher mode?
		let finisherChoice = null;			// NEW: Which finisher was chosen?
		let finisherTimer = 0;				// NEW: Countdown timer
		let finisherCountdown = null;
		let gamePaused = false;				// NEW: Pause state
        
	// Players Stats
	const characterStats = {
	    player: {
		name: 'HERO',
		color: '#ff6b6b',
		health: 200,
		speed: 3,
		jumpPower: 15,
		damageMultiplier: 1.0
	    },

	    enemy1: {
		name: 'ENEMY 1',
		color: '#6ba3ff',
		health: 200,
		speed: 3,
		jumpPower: 15,
		difficulty: 'easy',
		damageMultiplier: 0.75
	    },

	    enemy2: {
		name: 'ENEMY 2',
		color: '#ff9933',
		health: 200,
		speed: 3,
		jumpPower: 10,
		difficulty: 'easy',
		damageMultiplier: 0.8
	    },

	    enemy3: {
		name: 'ENEMY 3',
		color: '#33ff57',
		health: 200,
		speed: 3,
		jumpPower: 15,
		difficulty: 'medium',
		damageMultiplier: 0.9
	    },

	    enemy4: {
		name: 'ENEMY 4',
		color: '#ffeb3b',
		health: 200,
		speed: 3,
		jumpPower: 15,
		difficulty: 'medium',
		damageMultiplier: 1.0
	    },

	    enemy5: {
		name: 'ENEMY 5',
		color: '#e91e63',
		health: 200,
		speed: 3,
		jumpPower: 17,
		difficulty: 'hard',
		damageMultiplier: 1.0
	    },

	    enemy6: {
		name: 'ENEMY 6',
		color: '#00bcd4',
		health: 200,
		speed: 3,
		jumpPower: 12,
		difficulty: 'hard',
		damageMultiplier: 1.2
	    },

	    boss: {
		name: 'BIG BOSS',
        color: '#9933ff',
		health: 300,
		speed: 4,
		jumpPower: 18,
		difficulty: 'boss',
		damageMultiplier: 1.5
	    }
	};

        // Fighter class
        class Fighter {
            constructor(x, y, stats, controls, isAI) {
		console.log('Fighter constructor called with:', {x, y, stats, controls, isAI});
   		    this.x = x;
   		    this.y = y;
		    this.width = 60;
		    this.height = 100;
		    this.color = stats.color;
		    this.velocityX = 0;
		    this.velocityY = 0;
		    this.speed = stats.speed;
		    this.jumpPower = stats.jumpPower;
		    this.health = stats.health;
		    this.maxHealth = stats.health;
		    this.isJumping = false;
		    this.controls = controls;
		    this.attacking = false;
		    this.attackTimer = 0;
			this.inHitstun = false;
			this.hitstunTimer = 0;
		    this.attackType = '';
		    this.blocking = false;
		    this.facingRight = x < canvas.width / 2;
		    this.difficulty = stats.difficulty;
		    this.damageMultiplier = stats.damageMultiplier || 1.0;
		    this.isAI = Boolean(isAI);
    
		    console.log('After assignment, this.isAI is:', this.isAI);
    
		    // AI-specific properties
		    this.aiThinkTimer = 0;
		    this.aiAction = null;
		    this.aiActionTimer = 0;
		    
		    // Attack hitboxes
		    this.attackBox = {
		        x: 0,
		        y: 0,
		        width: 0,
		        height: 0
		    };
		}
            
            update(opponent) {
                // Update timers
                if (this.attackTimer > 0) this.attackTimer--;
				if (this.hitstunTimer > 0) {
					this.hitstunTimer--;
					if (this.hitstunTimer === 0) {
						this.inHitstun = false;
					}
				}
                
                // Face opponent
                this.facingRight = this.x < opponent.x;
                
                // AI Logic
                if (this.isAI) {
                    console.log('Calling updateAI for AI fighter');
                    this.updateAI(opponent);
                } else {
                    // Human player controls
                    this.handlePlayerInput(opponent);
                }
                
                // Apply gravity
                this.velocityY += GRAVITY;
                
                // Update position
                this.x += this.velocityX;
                this.y += this.velocityY;
                
                // Ground collision
                if (this.y + this.height >= GROUND) {
                    this.y = GROUND - this.height;
                    this.velocityY = 0;
                    this.isJumping = false;
                }
                
                // Screen boundaries
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
                
                if (this.attacking) {
                    this.attackTimer--;
                    if (this.attackTimer <= 0) {
                        this.attacking = false;
                        this.attackBox.width = 0;
                    }
                }
            }
            
            handlePlayerInput(opponent) {
				// Can't do anything during hitstun
				if (this.inHitstun) return;
				
                // Handle blocking
                this.blocking = keys[this.controls.block];
                
                // Movement (can't move while attacking)
                if (!this.attacking) {
                    this.velocityX = 0;
                    
                    if (keys[this.controls.left]) {
                        this.velocityX = -this.speed;
                    }
                    if (keys[this.controls.right]) {
                        this.velocityX = this.speed;
                    }
                    if (keys[this.controls.up] && !this.isJumping) {
                        this.velocityY = -this.jumpPower;
                        this.isJumping = true;
                    }
                }
                
                // Attack logic
                if (!this.attacking && this.attackTimer <= 0 && !this.blocking) {
                    if (keys[this.controls.special]) {
                        this.attack('special', 8, 15, 300, 30);
                    } else if (keys[this.controls.punch]) {
                        this.attack('punch', 6, 15, 35, 25);
                    } else if (keys[this.controls.kick]) {
                        this.attack('kick', 10, 20, 50, 35);
                    }
                }
            }
            
            updateAI(opponent) {
				// Can't do anything during hitstun
				if (this.inHitstun) return;
				
                // AI thinking timer - makes decisions every 30-60 frames
                this.aiThinkTimer++;
                
                const distance = Math.abs(this.x - opponent.x);
                const difficultySettings = {
					easy: { thinkSpeed: 20, blockChance: 0.1, attackRange: 80, aggression: 0.3 },
					medium: { thinkSpeed: 18, blockChance: 0.4, attackRange: 100, aggression: 0.7 },
					hard: { thinkSpeed: 15, blockChance: 0.6, attackRange: 150, aggression: 0.9 },
					boss: { thinkSpeed: 5, blockChance: 0.8, attackRange: 180, aggression: 1.0 }
				};
                
                const settings = difficultySettings[this.difficulty];
                
                // Debug logging
                if (this.aiThinkTimer === 1) {
                    console.log('AI Update - Distance:', distance, 'Current Action:', this.aiAction, 'Timer:', this.aiActionTimer);
                }
                
                // Make new decision
                if (this.aiThinkTimer >= settings.thinkSpeed) {
                    this.aiThinkTimer = 0;
                    
                    console.log('AI making new decision. Distance:', distance);
                    
                    // Should we block?
                    if (opponent.attacking && Math.random() < settings.blockChance) {
                        this.aiAction = 'block';
                        this.aiActionTimer = 20;
                        console.log('AI decided to BLOCK');
                    }
                    // Are we in attack range?
                    else if (distance < settings.attackRange && Math.random() < settings.aggression) {
                        const attacks = ['punch', 'special', 'kick'];
                        this.aiAction = attacks[Math.floor(Math.random() * attacks.length)];
                        this.aiActionTimer = 30;
                        console.log('AI decided to ATTACK:', this.aiAction);
                    }
                    // Should we jump?
                    else if (!this.isJumping && Math.random() < 0.15) {
                        this.aiAction = 'jump';
                        this.aiActionTimer = 10;
                        console.log('AI decided to JUMP');
                    }
                    // Move toward opponent
                    else if (distance > 60) {
                        this.aiAction = 'moveToward';
                        this.aiActionTimer = 40;
                        console.log('AI decided to MOVE TOWARD');
                    }
                    // Move away if too close
                    else if (distance < 40) {
                        this.aiAction = 'moveAway';
                        this.aiActionTimer = 30;
                        console.log('AI decided to MOVE AWAY');
                    }
                    else {
                        this.aiAction = 'idle';
                        this.aiActionTimer = 20;
                        console.log('AI decided to IDLE');
                    }
                }
                
                // Execute current action
                if (this.aiActionTimer > 0) {
                    this.aiActionTimer--;
                }
                
                this.velocityX = 0;
                this.blocking = false;
                
                if (!this.aiAction) {
                    console.log('AI has no action!');
                    return;
                }
                
                if (this.aiAction === 'block') {
                    this.blocking = true;
                }
                else if (this.aiAction === 'moveToward' && !this.attacking) {
                    this.velocityX = this.x < opponent.x ? this.speed : -this.speed;
                }
                else if (this.aiAction === 'moveAway' && !this.attacking) {
                    this.velocityX = this.x < opponent.x ? -this.speed : this.speed;
                }
                else if (this.aiAction === 'jump' && !this.isJumping && !this.attacking) {
                    this.velocityY = -this.jumpPower;
                    this.isJumping = true;
                    this.aiAction = 'idle';
                }
                else if (this.aiAction === 'punch' || this.aiAction === 'kick' || this.aiAction === 'special') {
                    if (!this.attacking && this.attackTimer <= 0) {
                        console.log('AI executing attack:', this.aiAction);
                        if (this.aiAction === 'special') {
                            this.attack('special', 8, 15, 300, 30);
                        } else if (this.aiAction === 'punch') {
                            this.attack('punch', 6, 15, 35, 25);
                        } else if (this.aiAction === 'kick') {
                            this.attack('kick', 10, 20, 50, 35);
                        }
                        this.aiAction = 'idle'; // Reset after attacking
                    }
                }
            }
            
            attack(type, damage, duration, width, height) {
                this.attacking = true;
                this.attackTimer = duration;
                this.attackType = type;
                
                // Set up attack hitbox
                this.attackBox.width = width;
                this.attackBox.height = height;
                this.attackBox.x = this.facingRight ? this.x + this.width : this.x - width;
                this.attackBox.y = this.y + this.height / 2 - height / 2;
            }
            
            takeDamage(damage, isBlocked, attackerFacingRight) {
                if (isBlocked) {
                    damage *= 0.2; // Blocked attacks do 20% damage
				} else {
					// Apply hitstun and pushback if not blocked
					this.inHitstun = true;
					this.hitstunTimer = 15;  // 15 frames of stun

					// Pushback: Move away from attacker
					const pushbackDistance = 30;
					if (attackerFacingRight) {
						this.x += pushbackDistance;  // Push right
					} else {
						this.x -= pushbackDistance;  // Push left
					}
				}
                
				this.health -= damage;
                if (this.health < 0) this.health = 0;
            }
            
            draw() {
                // Draw fighter body
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Draw head
                ctx.fillStyle = this.color === '#ff6b6b' ? '#ff8888' : '#6b9bff';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + 20, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw eyes (different for callout animation)
                ctx.fillStyle = '#000';
                const eyeOffset = this.facingRight ? 5 : -5;
                
                if (this.isCallout) {
                    // Normal eyes
                    ctx.fillRect(this.x + this.width / 2 - 8 + eyeOffset, this.y + 15, 4, 4);
                    ctx.fillRect(this.x + this.width / 2 + 4 + eyeOffset, this.y + 15, 4, 4);
                }
                
                // Draw blocking indicator
                if (this.blocking) {
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(this.x - 5, this.y - 5, this.width + 10, this.height + 10);
                }
                
                // Draw attack hitbox (for debugging/visual feedback)
                if (this.attacking && this.attackBox.width > 0) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.fillRect(this.attackBox.x, this.attackBox.y, this.attackBox.width, this.attackBox.height);
                    
                    // Draw attack effect
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.attackBox.x, this.attackBox.y, this.attackBox.width, this.attackBox.height);
                }
            }
        }
        
        // Keyboard input
        const keys = {};

		// Start button blinking effect
		let blinkInterval = null;
		let currentFrame = 1;

		function startButtonBlink() {
			const btn = document.getElementById('btnSinglePlayer');
			if (!btn) return;

			blinkInterval = setInterval(() => {
				currentFrame = currentFrame === 1 ? 2 : 1;
				btn.src = `images/start-${currentFrame}.png`;
				}, 1000);
		}

		function stopButtonBlink() {
			if (blinkInterval) {
				clearInterval(blinkInterval);
				blinkInterval = null;
			}
		}

        // Play announcement animation
        function playAnnouncement(animName, callback) {
            const img = document.getElementById('announcementImage');
            let currentFrame = 1;
            let frameCount = 0;
            let blinkInterval = null;
            
            // Set initial image (red)
            img.src = `images/${animName}-1.png`;
            img.style.display = 'block';
            img.className = 'announcement-animate';
            
            // Frame timing at 24fps = ~41.67ms per frame
            const frameTime = 1000 / 24;
            
            // Start frame counter
            const animationInterval = setInterval(() => {
                frameCount++;
                
                // Frames 1-5: Zoom in, stay red
                if (frameCount <= 5) {
                    img.src = `images/${animName}-1.png`;
                }
                // Frames 6-45: Alternate between yellow and red
                else if (frameCount <= 45) {
                    // Start with yellow (frame 6), alternate every frame
                    currentFrame = (frameCount % 2 === 0) ? 1 : 2;
                    img.src = `images/${animName}-${currentFrame}.png`;
                }
                // Frames 46-49: Zoom out, stay red
                else if (frameCount <= 49) {
                    img.src = `images/${animName}-1.png`;
                }
                // Animation complete
                else {
                    clearInterval(animationInterval);
					
					// Force animation to complete and reset
					setTimeout(() => {
						img.style.display = 'none';
						img.className = '';
						
						// Small delay before callback to ensure clean reset
						setTimeout(() => {
							if (callback) callback();
						}, 50);
					}, 50);
				}
			}, frameTime);
		}
		
		// Background video control
        let bgIntroPlayed = false;
        
        function playBackgroundIntro(callback) {
            const bgContainer = document.getElementById('bgContainer');
            const bgVideo = document.getElementById('bgVideo');
            const bgForeground = document.getElementById('bgForeground');
            const videoSource = bgVideo.querySelector('source');

			// Determine which background based on current fight
			const bgNumber = currentFight;
            console.log('Starting background intro sequence');
            
            // Load intro video
			console.log('ðŸŽ¬ LOADING INTRO:', `backgrounds/bg-${bgNumber}-intro.mp4`);
            videoSource.src = `backgrounds/bg-${bgNumber}-intro.mp4`;
            bgVideo.load();
            
            // Show container
            bgContainer.style.display = 'block';
			document.getElementById('fgContainer').style.display = 'block';
            
            // Set initial scale (showing full 1920 width in 1024 canvas)
            bgVideo.style.transform = 'translate(-50%, -59%) scale(0.56)';
			
			// Show foreground immediately
            bgForeground.src = `backgrounds/bg-${bgNumber}-fg.png`;
            bgForeground.style.display = 'block';
            bgForeground.style.transform = 'translate(-50%, -59%) scale(0.56)';
			
            bgVideo.play();
            
            // At 3 seconds, show Round 1 animation
            setTimeout(() => {
                console.log('Showing Round 1 overlay');
                playAnnouncement('round-1', () => {
                    console.log('Round 1 animation complete');
                });
            }, 3000);
			
            // At 5 seconds, start zoom AND switch to loop
            setTimeout(() => {
                console.log('Starting zoom sequence');
                bgVideo.classList.add('bg-zoom-in');
				bgForeground.classList.add('fg-zoom-in');
                
                // Hide intro video completely to prevent flashing
                bgVideo.style.opacity = '0';
                
                // Switch to loop video immediately
                console.log('ðŸ”„ SWITCHING TO LOOP:', `backgrounds/bg-${bgNumber}-loop.mp4`);
                videoSource.src = `backgrounds/bg-${bgNumber}-loop.mp4`;
                bgVideo.loop = true;
                bgVideo.load();
                
                // Show loop video once loaded
                bgVideo.onloadeddata = () => {
                    bgVideo.play();
                    bgVideo.style.opacity = '1';
                };
                
                // At 8 seconds (3s into zoom), show FIGHT! animation
                setTimeout(() => {
                    console.log('Showing FIGHT! overlay');
                    playAnnouncement('fight', () => {
                        console.log('FIGHT! animation complete, starting combat');
                        
                        // Mark intro as played
                        bgIntroPlayed = true;
                        
                        if (callback) callback();
                    });
                }, 3000);
            }, 5000);
        }
        
        function skipToBackgroundLoop() {
            const bgContainer = document.getElementById('bgContainer');
            const bgVideo = document.getElementById('bgVideo');
            const bgForeground = document.getElementById('bgForeground');
            const videoSource = bgVideo.querySelector('source');
            
            // Determine which background
            const bgNumber = currentFight;
            console.log('Skipping to background loop for fight', bgNumber);
            
            // Show container
            bgContainer.style.display = 'block';
			document.getElementById('fgContainer').style.display = 'block';
            
            // Already zoomed in state
            bgVideo.style.transform = 'translate(-50%, -59%) scale(1)';
            bgForeground.style.transform = 'translate(-50%, -59%) scale(0.9)';
            
            // Load loop video
            videoSource.src = `backgrounds/bg-${bgNumber}-loop.mp4`;
            bgVideo.load();
            bgVideo.play();
            
            // Show foreground
            bgForeground.src = `backgrounds/bg-${bgNumber}-fg.png`;
            bgForeground.style.display = 'block';
        }
		
        // Mode selection buttons
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, setting up controls');

			// Show video background
			document.getElementById('startVideo').style.display = 'block';
			
			// Start button blink
			startButtonBlink();

			const startBtn = document.getElementById('btnSinglePlayer');

			// Handle click
			startBtn.addEventListener('click', function() {
				console.log('Start game clicked');
				stopButtonBlink();
				startGame();
			});

			// Handle press effect (shows start-1.png and scales down)
			startBtn.addEventListener('mousedown', function() {
				stopButtonBlink();
				this.src = 'images/start-1.png';
				this.style.transform = 'scale(0.95)';
			});

			startBtn.addEventListener('mouseup', function() {
				this.style.transform = 'scale(1)';
			});
			
			// NEW: Pause menu button handlers
			document.getElementById('resumeBtn').addEventListener('click', resumeGame);
			document.getElementById('restartBtn').addEventListener('click', restartFight);
			document.getElementById('quitBtn').addEventListener('click', quit);
        });
        
        window.addEventListener('keydown', (e) => {
			// ESC to pause/unpause
			if (e.key === 'Escape') {
				togglePause();
				return;
			}
			
            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false;

			// NEW: Finisher selection
			if (inFinisher && !finisherChoice) {
				if (e.key.toLowerCase() === 'j') {
					chooseFinisher('flirty');
				} else if (e.key.toLowerCase() === 'k') {
					chooseFinisher('funny');
				} else if (e.key.toLowerCase() === 'l') {
					chooseFinisher('fatal');
				}
			}
        });
        
        // Initialize fighters
        let player1, player2;
        
        function startGame() {
            console.log('Starting game');
            document.getElementById('modeButtons').classList.add('hidden');
			document.getElementById('startVideo').style.display = 'none';
			document.querySelector('.game-container').style.display = 'block';
            initGame();

			// Show first VS screen
			const firstEnemyName = characterStats.enemy1.name;
			showVSScreen(firstEnemyName);
			
            console.log('Game initialized. Player1:', player1, 'Player2:', player2);
        }
        
        function initGame() {
			console.log('initGame called. currentFight:', currentFight);
			
            const playerControls = {
                left: 'a',
                right: 'd',
                up: 'w',
                down: 's',
                punch: 'g',
				kick: 'b',
                special: 'h',
                block: 'f'
            };
            
	    	// Create player
			player1 = new Fighter(150, GROUND - 100, characterStats.player, playerControls, false);
            
	    	// Create AI opponent based on current fight
			const enemyKey = currentFight === 7 ? 'boss' : `enemy${currentFight}`;
				console.log('enemyKey:', enemyKey);
  				console.log('characterStats[enemyKey]:', characterStats[enemyKey]);
			player2 = new Fighter(canvas.width - 200, GROUND - 100, characterStats[enemyKey], {}, true);

	    	// Update UI labels
			document.getElementById('player1Health').parentElement.previousElementSibling.textContent = characterStats.player.name;
			document.getElementById('player2Health').parentElement.previousElementSibling.textContent = characterStats[enemyKey].name;

			// Reset round tracking
			currentRound = 1; 
			player1RoundWins = 0;
			player2RoundWins = 0;

			// Clear round win indicators
			updateRoundWins();
            
            gameOver = false;
			gameInCombat = false;  // NEW: Wait for VS screen + Round announcement
            lastActionTime = Date.now();
            document.getElementById('gameOver').style.display = 'none';
			
		}

		// ROUNDS
		function startRound() {
   			console.log('Starting round', currentRound);

			gameInCombat = false;  // NEW: Pause game during transition
    
    		// Reset fighter positions
    		player1.x = 150;
    		player1.y = GROUND - 100;
    		player2.x = canvas.width - 200;
    		player2.y = GROUND - 100;
    
    		// Reset health
   			player1.health = player1.maxHealth;
    		player2.health = player2.maxHealth;

			// Update health bars immediately
    		updateHealthBars();
			
    		// Reset velocities
    		player1.velocityX = 0;
    		player1.velocityY = 0;
    		player2.velocityX = 0;
    		player2.velocityY = 0;
    
    		// Reset game state
    		gameOver = false;
    
    		// Show "ROUND X - FIGHT!"
    		showRoundMessage();
			}

		function showRoundMessage() {
			console.log('Showing Round', currentRound);
    
    		// First round with intro sequence
    		if (currentRound === 1 && !bgIntroPlayed) {
        		playBackgroundIntro(() => {
            		gameInCombat = true;
            		console.log('Game started! Fight begins!');
        		});
    		}
    		// Subsequent rounds - simple announcements
    		else {
        		if (!bgIntroPlayed) {
            		skipToBackgroundLoop();
            		bgIntroPlayed = true;
        		}
        		
        		playAnnouncement(`round-${currentRound}`, () => {
            		playAnnouncement('fight', () => {
                		gameInCombat = true;
                		console.log('Game started! Fight begins!');
            		});
        		});
    		}
		}

		function showVSScreen(enemyName) {
			console.log('Showing VS screen:', characterStats.player.name, 'vs', enemyName);
			
			// Show black overlay
			const overlay = document.getElementById('vsOverlay');
			    console.log('Overlay element:', overlay);
			
			if (!overlay) {
				console.error('vsOverlay element not found! Check HTML.');
				return;
			}
			
			const content = document.getElementById('vsContent');
			
			// Build VS screen content
			content.innerHTML = `
				<div class="character-name">${characterStats.player.name}</div>
				<div class="vs-text">VS</div>
				<div class="character-name">${enemyName}</div>
			`;
			
			overlay.style.display = 'flex';
			
			// Hide after 3 seconds and start the fight
			setTimeout(() => {
				overlay.style.display = 'none';
				showRoundMessage(); // Start Round 1
			}, 3000);
		}

		function startFinisher() {
			console.log('Starting finisher sequence. currentFight is:', currentFight);

			inFinisher = true;
			gameInCombat = false;
			finisherChoice = null;

			// Clear round win indicators
			document.getElementById('player1Wins').innerHTML = '';
			document.getElementById('player2Wins').innerHTML = '';

			// Show finisher overlay
			document.getElementById('finisherOverlay').style.display = 'flex';
			
			// Show "FINISHER!" video
			playAnnouncement('finisher', () => {
				showFinisherOptions();
			}, 1500);
		}

		function showFinisherOptions() {
			// Create finisher options container
			const optionsDiv = document.createElement('div');
			optionsDiv.id = 'finisherOptions';
			optionsDiv.style.cssText = `
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				display: flex;
				gap: 50px;
				z-index: 10001;
			`;

			// Add three finisher images
			const finishers = ['flirty', 'funny', 'fatal'];
			finishers.forEach(type => {
				const img = document.createElement('img');
				img.src = `images/finisher-${type}.png`;
				img.alt = type.toUpperCase();
				img.style.cssText = `
					width: 200px;
					height: auto;
					cursor: pointer;
					transition: transform 0.2s;
				`;
				img.onmouseover = () => img.style.transform = 'scale(1.1)';
				img.onmouseout = () => img.style.transform = 'scale(1)';
				img.onclick = () => chooseFinisher(type);
				optionsDiv.appendChild(img);
			});

			document.body.appendChild(optionsDiv);
		}

		function chooseFinisher(choice) {
			if (!inFinisher) return;
			
			console.log('Finisher chosen:', choice);
			finisherChoice = choice;
			
			// Remove finisher options
			const optionsDiv = document.getElementById('finisherOptions');
			if (optionsDiv) optionsDiv.remove();
			
			// Hide grey overlay
			document.getElementById('finisherOverlay').style.display = 'none';
			
			// Show finisher choice video
			playAnnouncement(choice, () => {
			
			// TODO: Play finisher animation here (step 6)
			// TODO: Play enemy reaction (step 6)
    
			// After finisher, show victory
				playAnnouncement('victory', () => {
					endFinisher();
				});
			});
		}

		function endFinisher() {
			console.log('Ending finisher');
    
			inFinisher = false;
    
			// Hide overlays and text
			document.getElementById('finisherOverlay').style.display = 'none';
			document.getElementById('gameOver').style.display = 'none';

			// Remove options if still present
			const optionsDiv = document.getElementById('finisherOptions');
			if (optionsDiv) optionsDiv.remove();
			
			// Continue to next fight
			continueToNextFight();
		}

		function continueToNextFight() {
			console.log('continueToNextFight called. currentFight BEFORE increment:', currentFight);
			currentFight++;
			console.log('continueToNextFight called. currentFight AFTER increment:', currentFight);
    
			// Reset round tracking for next fight
			currentRound = 1;
			player1RoundWins = 0;
			player2RoundWins = 0;
    
			if (currentFight > 7) {
				// Beat the boss!
				gameOver = true;
				const gameOverDiv = document.getElementById('gameOver');
				gameOverDiv.textContent = 'YOU WIN! GAME COMPLETE!';
				gameOverDiv.style.display = 'block';
			} else {
				// Load next enemy
				// Get next enemy name
				const nextEnemyKey = currentFight === 7 ? 'boss' : `enemy${currentFight}`;
				const nextEnemyName = characterStats[nextEnemyKey].name;
            
				// Create fighters
				initGame();

				// Update health bars immediately
				updateHealthBars();
            
				// Show VS screen
				showVSScreen(nextEnemyName);
			}
		}

		function togglePause() {
			// Can't pause during finisher or game over
			if (inFinisher || gameOver) return;

			gamePaused = !gamePaused;

			const overlay = document.getElementById('pauseOverlay');

			if (gamePaused) {
				console.log('Game paused');
				overlay.style.display = 'flex';
			} else {
				console.log('Game resumed');
				overlay.style.display = 'none';
			}
		}

		function resumeGame() {
			if (gamePaused) {
				togglePause();
			}
		}

		function restartFight() {
			console.log('Restarting fight');

			// Reset round tracking
			currentRound = 1;
			player1RoundWins = 0;
			player2RoundWins = 0;

			// Hide pause menu
			gamePaused = false;
			document.getElementById('pauseOverlay').style.display = 'none';

			// Restart the current fight
			initGame();

			// Show VS screen
			const enemyKey = currentFight === 7 ? 'boss' : `enemy${currentFight}`;
			const enemyName = characterStats[enemyKey].name;
			showVSScreen(enemyName);
		}

		function quit() {
			console.log('Quitting');

			// Reset everything
			currentFight = 1;
			currentRound = 1;
			player1RoundWins = 0;
			player2RoundWins = 0;
			gameOver = false;
			gamePaused = false;

			// Hide pause menu and game
			document.getElementById('pauseOverlay').style.display = 'none';
			document.querySelector('.game-container').style.display = 'none';

			// Show mode selection
			document.getElementById('modeButtons').classList.remove('hidden');
			document.getElementById('startVideo').style.display = 'block';
			startButtonBlink();

			// Clear canvas
			player1 = null;
			player2 = null;
		}
        
        // Check collision between attack and opponent
        function checkCollision(attacker, defender) {
            if (!attacker.attacking || attacker.attackBox.width === 0) return false;
            
            return attacker.attackBox.x < defender.x + defender.width &&
                   attacker.attackBox.x + attacker.attackBox.width > defender.x &&
                   attacker.attackBox.y < defender.y + defender.height &&
                   attacker.attackBox.y + attacker.attackBox.height > defender.y;
        }
        
        // Update health bars
        function updateHealthBars() {
            const p1Health = document.getElementById('player1Health');
            const p2Health = document.getElementById('player2Health');
            
            const p1Percent = (player1.health / player1.maxHealth) * 100;
            const p2Percent = (player2.health / player2.maxHealth) * 100;
            
            p1Health.style.width = p1Percent + '%';
            p2Health.style.width = p2Percent + '%';
            
            // Change color based on health
            p1Health.className = 'health-bar';
            p2Health.className = 'health-bar';
            
            if (p1Percent < 30) p1Health.className += ' critical';
            else if (p1Percent < 50) p1Health.className += ' low';
            
            if (p2Percent < 30) p2Health.className += ' critical';
            else if (p2Percent < 50) p2Health.className += ' low';
        }

		function updateRoundWins() {
			const p1Wins = document.getElementById('player1Wins');
			const p2Wins = document.getElementById('player2Wins');

			// Clear existing
			p1Wins.innerHTML = '';
			p2Wins.innerHTML = '';

			// Add coins for player 1
			for (let i = 0; i < player1RoundWins; i++) {
				const coin = document.createElement('img');
				coin.src = 'images/coin.png';
				coin.alt = 'Round Win';
				coin.className = 'win-coin';
				p1Wins.appendChild(coin);
			}

			// Add coins for player 2
			for (let i = 0; i < player2RoundWins; i++) {
				const coin = document.createElement('img');
				coin.src = 'images/coin.png';
				coin.alt = 'Round Win';
				coin.className = 'win-coin';
				p1Wins.appendChild(coin);
			}
		}
			
        // Game loop
        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

			// Wait for fighters to exist
			if (!player1 || !player2) {
				requestAnimationFrame(gameLoop);
				return;
            }
            
            if (!gameOver && gameInCombat && !gamePaused) {  // â† Added !gamePaused
                // Update fighters
                player1.update(player2);
                player2.update(player1);
                
                // Check collisions
                if (checkCollision(player1, player2)) {
                    let damage = 0;
                    if (player1.attackType === 'special') damage = 8;
                    else if (player1.attackType === 'punch') damage = 6;
                    else if (player1.attackType === 'kick') damage = 10;
                    
                    player2.takeDamage(damage, player2.blocking, player1.facingRight);
                    player1.attackBox.width = 0; // Hit detected, remove hitbox
                    
                    if (player2.health <= 0) {
						// Player won the round!
						player1RoundWins++;
						console.log('Player wins round! Score:', player1RoundWins, '-', player2RoundWins);
						updateRoundWins();  // NEW: Show coin

						if (player1RoundWins >= 2) {
        					// WON THE MATCH! Show finisher
        					console.log('Player wins match! Starting finisher...');
        					gameOver = true;

							// Short delay, then start finisher
							setTimeout(() => {
								startFinisher();
							}, 1000);
						} else {
							// Won the round but not the match - start next round
							console.log('Starting next round...');
							currentRound++;
							gameOver = true;

							// Show round result
							playAnnouncement('you-win', () => {
								startRound();
							});
						}
					}
				}
                
                if (checkCollision(player2, player1)) {
                    let damage = 0;
                    if (player2.attackType === 'special') damage = 8;
                    else if (player2.attackType === 'puch') damage = 6;
                    else if (player2.attackType === 'kick') damage = 10;
                    
                    player1.takeDamage(damage, player2.blocking, player1.facingRight);
                    player2.attackBox.width = 0;
                    
                    if (player1.health <= 0) {
						// AI won the round!
						player2RoundWins++;
						console.log('AI wins round! Score:', player1RoundWins, '-', player2RoundWins);
						updateRoundWins();  // NEW: Show coin

						if (player2RoundWins >= 2) {
							// Lost the match - GAME OVER!

							console.log('AI wins match - Game Over!');
							gameOver = true;
							endGame();
						} else {
						// Lost the round but not the match - start next round
							console.log('Starting next round...');
							currentRound++;
							gameOver = true;

							// Show round result
							playAnnouncement('you-lose', () => {
								startRound();
							});
						}
					}
				}
				
                // Update UI
                updateHealthBars();
            }
            
            // Draw fighters
            player1.draw();
            player2.draw();
            
            requestAnimationFrame(gameLoop);
        }
        
        function endGame() {
            if (currentFight > 7 && player1.health > 0) {
                // Game complete - will be replaced with full animation/credits later
                const gameOverDiv = document.getElementById('gameOver');
                gameOverDiv.textContent = 'GAME COMPLETE!';
                gameOverDiv.style.display = 'block';
            } else if (player1.health <= 0) {
                playAnnouncement('you-lose');
            } else {
                playAnnouncement('victory');
            }
        }
        // Start game loop (but don't init yet - wait for button click)
		gameLoop();
    </script>
</body>
</html>
