<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fighting Game Prototype</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            background: #000000;
            font-family: "Honk", sans-serif;
            overflow-x: hidden;
            padding-top: 10px;
            padding-bottom: 200px; /* Space for controls */
        }
        
        .game-container {
            position: relative;
            width: 100%;
            max-width: 1080px;
            margin: 0 auto;
        }
        
        #gameCanvas {
            border: 5px solid #ff0000;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 50%, #8B7355 50%, #654321 100%);
            width: 100%;
            height: auto;
            display: block;
        }
        
        .mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            padding: 10px;
            background: rgba(0,0,0,0.95);
            z-index: 1000;
            border-top: 3px solid #FFD700;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            justify-content: center;
            align-items: center;
        }
        
        .d-pad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 3px;
            max-width: 180px;
        }
        
        .d-pad button {
            width: 50px;
            height: 50px;
            font-size: 20px;
            border: 2px solid #fff;
            background: rgba(100, 100, 100, 0.8);
            color: white;
            border-radius: 8px;
            font-weight: bold;
            touch-action: none;
        }
        
        @media (min-width: 600px) {
            .d-pad button {
                width: 60px;
                height: 60px;
                font-size: 24px;
            }
        }
        
        .d-pad button:active {
            background: rgba(150, 150, 150, 0.9);
        }
        
        .d-pad .empty {
            background: transparent;
            border: none;
        }
        
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 3px;
            max-width: 180px;
        }
        
        .action-buttons button {
            width: 80px;
            height: 45px;
            font-size: 12px;
            border: 2px solid #fff;
            background: rgba(220, 50, 50, 0.8);
            color: white;
            border-radius: 8px;
            font-weight: bold;
            touch-action: none;
        }
        
        @media (min-width: 600px) {
            .action-buttons button {
                width: 90px;
                height: 50px;
                font-size: 14px;
            }
        }
        
        .action-buttons button:active {
            background: rgba(255, 80, 80, 0.9);
        }
        
        .action-buttons button.block {
            grid-column: 1 / -1;
            background: rgba(50, 150, 220, 0.8);
        }
        
        .action-buttons button.block:active {
            background: rgba(80, 180, 255, 0.9);
        }
        
        .mode-buttons {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 999;
        }
        
        .mode-buttons button {
            padding: 20px 40px;
            font-size: 24px;
            font-weight: bold;
            background: rgba(255, 215, 0, 0.9);
            border: 3px solid white;
            border-radius: 10px;
            color: #000;
            cursor: pointer;
            touch-action: none;
        }
        
        .mode-buttons button:active {
            background: rgba(255, 235, 50, 1);
        }
        
        .mode-buttons.hidden {
            display: none;
        }
        
        .ui-container {
            position: absolute;
            top: 10px;
            left: 0;
            right: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
        }
        
        .player-hud {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .player-name {
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .health-bar-container {
            width: 150px;
            height: 20px;
            background: #333;
            border: 2px solid #fff;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
        }
        
        @media (min-width: 600px) {
            .player-name {
                font-size: 24px;
            }
            .health-bar-container {
                width: 300px;
                height: 30px;
                border: 3px solid #fff;
            }
        }
        
        .health-bar {
            height: 100%;
            background: linear-gradient(to bottom, #4CAF50 0%, #45a049 100%);
            transition: width 0.3s ease;
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
        }
        
        .health-bar.low {
            background: linear-gradient(to bottom, #ff9800 0%, #ff6f00 100%);
        }
        
        .health-bar.critical {
            background: linear-gradient(to bottom, #f44336 0%, #d32f2f 100%);
            animation: pulse 0.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        

        
        .game-over {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            color: #FFD700;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.9);
            display: none;
            animation: fadeIn 0.75s;
			animation: fadeOut 0.5s;

        }

		#vsOverlay {
    		position: fixed;
    		top: 0;
    		left: 0;
    		width: 100vw;
    		height: 100vh;
    		background: #000000;
    		z-index: 9999;
    		display: flex;
    		justify-content: center;
    		align-items: center;
		}

		#finisherOverlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100vw;
			height: 100vh;
			background: rgba(0, 0, 0, 0.9);
			z-index: 9999;
			display: flex;
			justify-content: center;
			align-items: center;
		}

		#finisherContent {
			font-size: 72px;
			color: #ff0000;
			text-shadow: 6px 6px 12px rgba(255,0,0,0.8);
			margin-bottom: 50px;
		}

		.finisher-options {
			display: flex;
			gap: 50px;
			justify-content: center;
			margin: 50px 0;
		}

		.finisher-option {
			display: flex;
			flex-direction: column;
			align-items: center;
			gap: 20px;
			padding: 30px;
			background: rgba(255,255,255,0.1);
			border: 3px solid #FFD700;
			border-radius: 10px;
			cursor: pointer;
			transition: all 0.3s;
		}

		.finisher-option:hover {
			background: rgba(255,215,0,0.2);
			transform: scale(1.05);
		}
		
		.finisher-option .key {
			font-size: 48px;
			color: #FFD700;
			font-weight: bold;
		}

		.finisher-option .name {
			font-size: 24px;
			color: white;
		}

		#finisherTimer {
			font-size: 96px;
			color: #ff0000;
			margin-top: 50px;
			animation: pulse 1s infinite;
		}

		@keyframes pulse {
			0%, 100% { opacity: 1; transform: scale(1); }
			50% { opacity: 0.7; transform: scale(1.1); }
		}

		#vsContent {
   			text-align: center;
    		color: white;
    		font-family: 'Arial Black', sans-serif;
		}

		#vsContent .character-name {
    		font-size: 64px;
    		color: #FFD700;
    		text-shadow: 4px 4px 8px rgba(0,0,0,0.9);
    		margin: 20px 0;
		}

		#vsContent .vs-text {
    		font-size: 96px;
    		color: #ff0000;
    		text-shadow: 6px 6px 12px rgba(255,0,0,0.8);
    		margin: 40px 0;
    		font-weight: bold;
		}
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        

    </style>
</head>
<body>
    <div class="mode-buttons" id="modeButtons">
        <button id="btnSinglePlayer">START GAME</button>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="1024" height="576"></canvas>
        <div class="ui-container">
            <div class="player-hud">
                <div class="player-name">PLAYER 1</div>
                <div class="health-bar-container">
                    <div class="health-bar" id="player1Health"></div>
                </div>
            </div>
            <div class="player-hud" style="align-items: flex-end;">
                <div class="player-name">PLAYER 2</div>
                <div class="health-bar-container">
                    <div class="health-bar" id="player2Health"></div>
                </div>
            </div>
        </div>

        <div class="game-over" id="gameOver"></div>
    </div>

	<div id="vsOverlay" style="display: none;">
		<div id="vsContent"></div>
	</div>
	
	<div id="finisherOverlay" style="display: none;">
		<div id="finisherContent">
			<h1>FINISH THEM!</h1>
			<div class="finisher-options">
				<div class="finisher-option">
					<span class="key">J</span>
					<span class="name">FLIRTY</span>
				</div>
				<div class="finisher-option">
					<span class="key">K</span>
					<span class="name">FUNNY</span>
				</div>
				<div class="finisher-option">
					<span class="key">L</span>
					<span class="name">FATAL</span>
				</div>
			</div>
			<div id="finisherTimer">5</div>
		</div>
	</div>
	
    <div class="controls-image">
        <h3>CONTROLS</h3>
        <div class="controls-grid">
            <div class="control-section">
                <h4>Controls</h4>
                <p>W/A/S/D - Move & Jump</p>
                <p>G - High Punch</p>
                <p>H - Low Punch</p>
                <p>B - High Kick</p>
                <p>N - Low Kick</p>
                <p>F - Block</p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const GRAVITY = 0.8;
        const GROUND = canvas.height - 100;
        const CALLOUT_IDLE_TIME = 30000;
        
        // Game state
        let gameOver = false;
		let gameInCombat = false;			// Controls whether fighters can move/attack
        let lastActionTime = Date.now();
        let currentFight = 1;				// Track which enemy (1-6 or boss)
		let currentRound = 1; 				// the round we are at
		let player1RoundWins = 0; 
		let player2RoundWins = 0;
		let inFinisher = false;				// NEW: Are we in finisher mode?
		let finisherChoice = null;			// NEW: Which finisher was chosen?
		let finisherTimer = 0;				// NEW: Countdown timer
        
	// Players Stats
	const characterStats = {
	    player: {
		name: 'HERO',
		color: '#ff6b6b',
		health: 200,
		speed: 3,
		jumpPower: 15,
		damageMultiplier: 1.0
	    },

	    enemy1: {
		name: 'ENEMY 1',
		color: '#6ba3ff',
		health: 200,
		speed: 3,
		jumpPower: 15,
		difficulty: 'easy',
		damageMultiplier: 0.75
	    },

	    enemy2: {
		name: 'ENEMY 2',
		color: '#ff9933',
		health: 200,
		speed: 3,
		jumpPower: 10,
		difficulty: 'easy',
		damageMultiplier: 0.8
	    },

	    enemy3: {
		name: 'ENEMY 3',
		color: '#33ff57',
		health: 200,
		speed: 3,
		jumpPower: 15,
		difficulty: 'medium',
		damageMultiplier: 0.9
	    },

	    enemy4: {
		name: 'ENEMY 4',
		color: '#ffeb3b',
		health: 200,
		speed: 3,
		jumpPower: 15,
		difficulty: 'medium',
		damageMultiplier: 1.0
	    },

	    enemy5: {
		name: 'ENEMY 5',
		color: '#e91e63',
		health: 200,
		speed: 3,
		jumpPower: 17,
		difficulty: 'hard',
		damageMultiplier: 1.0
	    },

	    enemy6: {
		name: 'ENEMY 6',
		color: '#00bcd4',
		health: 200,
		speed: 3,
		jumpPower: 12,
		difficulty: 'hard',
		damageMultiplier: 1.2
	    },

	    boss: {
		name: 'BIG BOSS',
        color: '#9933ff',
		health: 300,
		speed: 4,
		jumpPower: 18,
		difficulty: 'boss',
		damageMultiplier: 1.5
	    }
	};

        // Fighter class
        class Fighter {
            constructor(x, y, stats, controls, isAI) {
		console.log('Fighter constructor called with:', {x, y, stats, controls, isAI});
   		    this.x = x;
   		    this.y = y;
		    this.width = 60;
		    this.height = 100;
		    this.color = stats.color;
		    this.velocityX = 0;
		    this.velocityY = 0;
		    this.speed = stats.speed;
		    this.jumpPower = stats.jumpPower;
		    this.health = stats.health;
		    this.maxHealth = stats.health;
		    this.isJumping = false;
		    this.controls = controls;
		    this.attacking = false;
		    this.attackTimer = 0;
		    this.attackType = '';
		    this.blocking = false;
		    this.isCallout = false;
		    this.calloutTimer = 0;
		    this.facingRight = x < canvas.width / 2;
		    this.difficulty = stats.difficulty;
		    this.damageMultiplier = stats.damageMultiplier || 1.0;
		    this.isAI = Boolean(isAI);
    
		    console.log('After assignment, this.isAI is:', this.isAI);
    
		    // AI-specific properties
		    this.aiThinkTimer = 0;
		    this.aiAction = null;
		    this.aiActionTimer = 0;
		    
		    // Attack hitboxes
		    this.attackBox = {
		        x: 0,
		        y: 0,
		        width: 0,
		        height: 0
		    };
		}
            
            update(opponent) {
                // Update timers
                if (this.attackTimer > 0) this.attackTimer--;
                
                // Update callout animation
                if (this.isCallout) {
                    this.calloutTimer++;
                    if (this.calloutTimer > 60) { // Callout lasts 60 frames (1 second)
                        this.isCallout = false;
                        this.calloutTimer = 0;
                    }
                    return; // Can't do anything during callout
                }
                
                // Face opponent
                this.facingRight = this.x < opponent.x;
                
                // AI Logic
                if (this.isAI) {
                    console.log('Calling updateAI for AI fighter');
                    this.updateAI(opponent);
                } else {
                    // Human player controls
                    this.handlePlayerInput(opponent);
                }
                
                // Apply gravity
                this.velocityY += GRAVITY;
                
                // Update position
                this.x += this.velocityX;
                this.y += this.velocityY;
                
                // Ground collision
                if (this.y + this.height >= GROUND) {
                    this.y = GROUND - this.height;
                    this.velocityY = 0;
                    this.isJumping = false;
                }
                
                // Screen boundaries
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
                
                if (this.attacking) {
                    this.attackTimer--;
                    if (this.attackTimer <= 0) {
                        this.attacking = false;
                        this.attackBox.width = 0;
                    }
                }
            }
            
            handlePlayerInput(opponent) {
                // Handle blocking
                this.blocking = keys[this.controls.block];
                
                // Movement (can't move while attacking)
                if (!this.attacking) {
                    this.velocityX = 0;
                    
                    if (keys[this.controls.left]) {
                        this.velocityX = -this.speed;
                    }
                    if (keys[this.controls.right]) {
                        this.velocityX = this.speed;
                    }
                    if (keys[this.controls.up] && !this.isJumping) {
                        this.velocityY = -this.jumpPower;
                        this.isJumping = true;
                    }
                }
                
                // Attack logic
                if (!this.attacking && this.attackTimer <= 0 && !this.blocking) {
                    if (keys[this.controls.special]) {
                        this.attack('special', 8, 15, 40, 30);
                    } else if (keys[this.controls.punch]) {
                        this.attack('punch', 6, 15, 35, 25);
                    } else if (keys[this.controls.kick]) {
                        this.attack('kick', 10, 20, 50, 35);
                    }
                }
            }
            
            updateAI(opponent) {
                // AI thinking timer - makes decisions every 30-60 frames
                this.aiThinkTimer++;
                
                const distance = Math.abs(this.x - opponent.x);
                const difficultySettings = {
			easy: { thinkSpeed: 20, blockChance: 0.1, attackRange: 80, aggression: 0.3 },
			medium: { thinkSpeed: 18, blockChance: 0.4, attackRange: 100, aggression: 0.7 },
			hard: { thinkSpeed: 15, blockChance: 0.6, attackRange: 150, aggression: 0.9 },
			boss: { thinkSpeed: 5, blockChance: 0.8, attackRange: 180, aggression: 1.0 }
                };
                
                const settings = difficultySettings[this.difficulty];
                
                // Debug logging
                if (this.aiThinkTimer === 1) {
                    console.log('AI Update - Distance:', distance, 'Current Action:', this.aiAction, 'Timer:', this.aiActionTimer);
                }
                
                // Make new decision
                if (this.aiThinkTimer >= settings.thinkSpeed) {
                    this.aiThinkTimer = 0;
                    
                    console.log('AI making new decision. Distance:', distance);
                    
                    // Should we block?
                    if (opponent.attacking && Math.random() < settings.blockChance) {
                        this.aiAction = 'block';
                        this.aiActionTimer = 20;
                        console.log('AI decided to BLOCK');
                    }
                    // Are we in attack range?
                    else if (distance < settings.attackRange && Math.random() < settings.aggression) {
                        const attacks = ['punch', 'special', 'kick'];
                        this.aiAction = attacks[Math.floor(Math.random() * attacks.length)];
                        this.aiActionTimer = 30;
                        console.log('AI decided to ATTACK:', this.aiAction);
                    }
                    // Should we jump?
                    else if (!this.isJumping && Math.random() < 0.15) {
                        this.aiAction = 'jump';
                        this.aiActionTimer = 10;
                        console.log('AI decided to JUMP');
                    }
                    // Move toward opponent
                    else if (distance > 60) {
                        this.aiAction = 'moveToward';
                        this.aiActionTimer = 40;
                        console.log('AI decided to MOVE TOWARD');
                    }
                    // Move away if too close
                    else if (distance < 40) {
                        this.aiAction = 'moveAway';
                        this.aiActionTimer = 30;
                        console.log('AI decided to MOVE AWAY');
                    }
                    else {
                        this.aiAction = 'idle';
                        this.aiActionTimer = 20;
                        console.log('AI decided to IDLE');
                    }
                }
                
                // Execute current action
                if (this.aiActionTimer > 0) {
                    this.aiActionTimer--;
                }
                
                this.velocityX = 0;
                this.blocking = false;
                
                if (!this.aiAction) {
                    console.log('AI has no action!');
                    return;
                }
                
                if (this.aiAction === 'block') {
                    this.blocking = true;
                }
                else if (this.aiAction === 'moveToward' && !this.attacking) {
                    this.velocityX = this.x < opponent.x ? this.speed : -this.speed;
                }
                else if (this.aiAction === 'moveAway' && !this.attacking) {
                    this.velocityX = this.x < opponent.x ? -this.speed : this.speed;
                }
                else if (this.aiAction === 'jump' && !this.isJumping && !this.attacking) {
                    this.velocityY = -this.jumpPower;
                    this.isJumping = true;
                    this.aiAction = 'idle';
                }
                else if (this.aiAction === 'punch' || this.aiAction === 'kick' || this.aiAction === 'special') {
                    if (!this.attacking && this.attackTimer <= 0) {
                        console.log('AI executing attack:', this.aiAction);
                        if (this.aiAction === 'special') {
                            this.attack('special', 8, 15, 40, 30);
                        } else if (this.aiAction === 'punch') {
                            this.attack('punch', 6, 15, 35, 25);
                        } else if (this.aiAction === 'kick') {
                            this.attack('kick', 10, 20, 50, 35);
                        }
                        this.aiAction = 'idle'; // Reset after attacking
                    }
                }
            }
            
            attack(type, damage, duration, width, height) {
                this.attacking = true;
                this.attackTimer = duration;
                this.attackType = type;
                
                // Set up attack hitbox
                this.attackBox.width = width;
                this.attackBox.height = height;
                this.attackBox.x = this.facingRight ? this.x + this.width : this.x - width;
                this.attackBox.y = this.y + this.height / 2 - height / 2;
            }
            
            takeDamage(damage, isBlocked) {
                if (isBlocked) {
                    damage *= 0.2; // Blocked attacks do 20% damage
                }
                this.health -= damage;
                if (this.health < 0) this.health = 0;
            }
            
            triggerCallout() {
                this.isCallout = true;
                this.calloutTimer = 0;
            }
            
            draw() {
                // Draw fighter body
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // Draw head
                ctx.fillStyle = this.color === '#ff6b6b' ? '#ff8888' : '#6b9bff';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + 20, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw eyes (different for callout animation)
                ctx.fillStyle = '#000';
                const eyeOffset = this.facingRight ? 5 : -5;
                
                if (this.isCallout) {
                    // Animated callout eyes - wider/excited
                    ctx.fillRect(this.x + this.width / 2 - 10 + eyeOffset, this.y + 15, 5, 6);
                    ctx.fillRect(this.x + this.width / 2 + 5 + eyeOffset, this.y + 15, 5, 6);
                    
                    // Draw mouth - open/shouting
                    ctx.beginPath();
                    ctx.arc(this.x + this.width / 2 + eyeOffset, this.y + 28, 4, 0, Math.PI);
                    ctx.fill();
                    
                    // Add exclamation mark above head
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText('!', this.x + this.width / 2 - 5, this.y - 10);
                } else {
                    // Normal eyes
                    ctx.fillRect(this.x + this.width / 2 - 8 + eyeOffset, this.y + 15, 4, 4);
                    ctx.fillRect(this.x + this.width / 2 + 4 + eyeOffset, this.y + 15, 4, 4);
                }
                
                // Draw blocking indicator
                if (this.blocking) {
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(this.x - 5, this.y - 5, this.width + 10, this.height + 10);
                }
                
                // Draw attack hitbox (for debugging/visual feedback)
                if (this.attacking && this.attackBox.width > 0) {
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.fillRect(this.attackBox.x, this.attackBox.y, this.attackBox.width, this.attackBox.height);
                    
                    // Draw attack effect
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.attackBox.x, this.attackBox.y, this.attackBox.width, this.attackBox.height);
                }
            }
        }
        
        // Keyboard input
        const keys = {};
        
        // Touch controls mapping
        const touchControls = {
            btnUp: 'w',
            btnLeft: 'a',
            btnRight: 'd',
            btnDown: 's',
            btnHighPunch: 'g',
            btnLowPunch: 'h',
            btnHighKick: 'b',
            btnLowKick: 'n',
            btnBlock: 'f'
        };
        
        // Mode selection buttons
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, setting up controls');
            
            document.getElementById('btnSinglePlayer').addEventListener('click', function() {
                console.log('Start game clicked');
                startGame();
            });
            
            // Set up touch controls
            Object.keys(touchControls).forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (!btn) {
                    console.error('Button not found:', btnId);
                    return;
                }
                const key = touchControls[btnId];
                
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys[key] = true;
                });
                
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys[key] = false;
                });
                
                // Also support mouse for testing on desktop
                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    keys[key] = true;
                });
                
                btn.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    keys[key] = false;
                });
            });
            
            console.log('Controls setup complete');
        });
        
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.key] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.key] = false;

			// NEW: Finisher selection
			if (inFinisher && !finisherChoice) {
				if (e.key.toLowerCase() === 'j') {
					chooseFinisher('flirty');
				} else if (e.key.toLowerCase() === 'k') {
					chooseFinisher('funny');
				} else if (e.key.toLowerCase() === 'l') {
					chooseFinisher('fatal');
				}
			}
        });
        
        // Initialize fighters
        let player1, player2;
        
        function startGame() {
            console.log('Starting game');
            document.getElementById('modeButtons').classList.add('hidden');
            initGame();

			// Show first VS screen
			const firstEnemyName = characterStats.enemy1.name;
			showVSScreen(firstEnemyName);
			
            console.log('Game initialized. Player1:', player1, 'Player2:', player2);
        }
        
        function initGame() {
			console.log('initGame called. currentFight:', currentFight);
			
            const playerControls = {
                left: 'a',
                right: 'd',
                up: 'w',
                down: 's',
                punch: 'g',
				kick: 'b',
                special: 'h',
                block: 'f'
            };
            
	    	// Create player
			player1 = new Fighter(150, GROUND - 100, characterStats.player, playerControls, false);
            
	    	// Create AI opponent based on current fight
			const enemyKey = currentFight === 7 ? 'boss' : `enemy${currentFight}`;
				console.log('enemyKey:', enemyKey);
  				console.log('characterStats[enemyKey]:', characterStats[enemyKey]);
			player2 = new Fighter(canvas.width - 200, GROUND - 100, characterStats[enemyKey], {}, true);

	    	// Update UI labels
			document.getElementById('player1Health').parentElement.previousElementSibling.textContent = characterStats.player.name;
			document.getElementById('player2Health').parentElement.previousElementSibling.textContent = characterStats[enemyKey].name;

			// Reset round tracking
			currentRound = 1; 
			player1RoundWins = 0;
			player2RoundWins = 0;
            
            gameOver = false;
			gameInCombat = false;  // NEW: Wait for VS screen + Round announcement
            lastActionTime = Date.now();
            document.getElementById('gameOver').style.display = 'none';
			
		}

		// ROUNDS
		function startRound() {
   			console.log('Starting round', currentRound);

			gameInCombat = false;  // NEW: Pause game during transition
    
    		// Reset fighter positions
    		player1.x = 150;
    		player1.y = GROUND - 100;
    		player2.x = canvas.width - 200;
    		player2.y = GROUND - 100;
    
    		// Reset health
   			player1.health = player1.maxHealth;
    		player2.health = player2.maxHealth;
    
    		// Reset velocities
    		player1.velocityX = 0;
    		player1.velocityY = 0;
    		player2.velocityX = 0;
    		player2.velocityY = 0;
    
    		// Reset game state
    		gameOver = false;
    
    		// Show "ROUND X - FIGHT!"
    		showRoundMessage();
			}

		function showRoundMessage() {
    		const gameOverDiv = document.getElementById('gameOver');
    		gameOverDiv.textContent = `ROUND ${currentRound}`;
    		gameOverDiv.style.display = 'block';

			console.log('Showing Round', currentRound);
    
    		// Show "FIGHT!" after 1.5 seconds
    		setTimeout(() => {
        		gameOverDiv.textContent = 'FIGHT!';
			
				// Start the game after another 1 second
				setTimeout(() => {
            		gameOverDiv.style.display = 'none';
					gameInCombat = true;  // NOW the game can actually start
					console.log('Game started! Fight begins!');
        		}, 1000);
    		}, 1500);
		}

		function showVSScreen(enemyName) {
			console.log('Showing VS screen:', characterStats.player.name, 'vs', enemyName);
			
			// Show black overlay
			const overlay = document.getElementById('vsOverlay');
			    console.log('Overlay element:', overlay);
			
			if (!overlay) {
				console.error('vsOverlay element not found! Check HTML.');
				return;
			}
			
			const content = document.getElementById('vsContent');
			
			// Build VS screen content
			content.innerHTML = `
				<div class="character-name">${characterStats.player.name}</div>
				<div class="vs-text">VS</div>
				<div class="character-name">${enemyName}</div>
			`;
			
			overlay.style.display = 'flex';
			
			// Hide after 3 seconds and start the fight
			setTimeout(() => {
				overlay.style.display = 'none';
				showRoundMessage(); // Start Round 1
			}, 3000);
		}

		function startFinisher() {
			console.log('Starting finisher sequence');

			inFinisher = true;
			gameInCombat = false;
			finisherChoice = null;
			finisherTimer = 5;

			// Show finisher overlay
			const overlay = document.getElementById('finisherOverlay');
			const timerDiv = document.getElementById('finisherTimer');
			overlay.style.display = 'flex';
			timerDiv.textContent = finisherTimer;

			// Start countdown
			const countdown = setInterval(() => {
				finisherTimer--;
				timerDiv.textContent = finisherTimer;

				if (finisherTimer <= 0 || finisherChoice !== null) {
					clearInterval(countdown);
					endFinisher();
				}
			}, 1000);
		}

		function chooseFinisher(choice) {
			if (!inFinisher) return;
			
			console.log('Finisher chosen:', choice);
			finisherChoice = choice;
    
			// Show which finisher was chosen
			const overlay = document.getElementById('finisherOverlay');
			const content = document.getElementById('finisherContent');
    
			let finisherName = '';
			if (choice === 'flirty') finisherName = 'FLIRTY FINISHER!';
			else if (choice === 'funny') finisherName = 'FUNNY FINISHER!';
			else if (choice === 'fatal') finisherName = 'FATAL FINISHER!';
    
			content.innerHTML = `<h1 style="font-size: 96px;">${finisherName}</h1>`;
    
			// Later: Play finisher animation here
			// For now, just wait 2 seconds
			setTimeout(() => {
				endFinisher();
			}, 2000);
		}

		function endFinisher() {
			console.log('Ending finisher');
    
			inFinisher = false;
    
			// Hide overlay
			document.getElementById('finisherOverlay').style.display = 'none';
    
			// If no choice was made, just continue
			if (finisherChoice === null) {
				console.log('No finisher chosen, auto-continuing');
			}
    
			// Continue to next fight
			continueToNextFight();
		}

		function continueToNextFight() {
			currentFight++;
    
			// Reset round tracking for next fight
			currentRound = 1;
			player1RoundWins = 0;
			player2RoundWins = 0;
    
			if (currentFight > 7) {
				// Beat the boss!
				gameOver = true;
				const gameOverDiv = document.getElementById('gameOver');
				gameOverDiv.textContent = 'YOU WIN! GAME COMPLETE!';
				gameOverDiv.style.display = 'block';
			} else {
				// Load next enemy
				const gameOverDiv = document.getElementById('gameOver');
				gameOverDiv.textContent = 'VICTORY!';
				gameOverDiv.style.display = 'block';
        
				setTimeout(() => {
					gameOverDiv.style.display = 'none';
            
					// Get next enemy name
					const nextEnemyKey = currentFight === 7 ? 'boss' : `enemy${currentFight}`;
					const nextEnemyName = characterStats[nextEnemyKey].name;
            
					// Create fighters
					initGame();
            
					// Show VS screen
					showVSScreen(nextEnemyName);
				}, 2000);
			}
		}


		// Reset action timer when any action occurs
        function resetActionTimer() {
            lastActionTime = Date.now();
            // Exit callout state if active
            player1.isCallout = false;
            player2.isCallout = false;
        }
        
        // Check collision between attack and opponent
        function checkCollision(attacker, defender) {
            if (!attacker.attacking || attacker.attackBox.width === 0) return false;
            
            return attacker.attackBox.x < defender.x + defender.width &&
                   attacker.attackBox.x + attacker.attackBox.width > defender.x &&
                   attacker.attackBox.y < defender.y + defender.height &&
                   attacker.attackBox.y + attacker.attackBox.height > defender.y;
        }
        
        // Update health bars
        function updateHealthBars() {
            const p1Health = document.getElementById('player1Health');
            const p2Health = document.getElementById('player2Health');
            
            const p1Percent = (player1.health / player1.maxHealth) * 100;
            const p2Percent = (player2.health / player2.maxHealth) * 100;
            
            p1Health.style.width = p1Percent + '%';
            p2Health.style.width = p2Percent + '%';
            
            // Change color based on health
            p1Health.className = 'health-bar';
            p2Health.className = 'health-bar';
            
            if (p1Percent < 30) p1Health.className += ' critical';
            else if (p1Percent < 50) p1Health.className += ' low';
            
            if (p2Percent < 30) p2Health.className += ' critical';
            else if (p2Percent < 50) p2Health.className += ' low';
        }
        
        // Game loop
        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw ground line
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, GROUND);
            ctx.lineTo(canvas.width, GROUND);
            ctx.stroke();

			// Wait for fighters to exist
			if (!player1 || !player2) {
				requestAnimationFrame(gameLoop);
				return;
            }
            
            if (!gameOver && gameInCombat) {
                // Check for callout trigger (30 seconds of inactivity)
                const timeSinceAction = Date.now() - lastActionTime;
                if (timeSinceAction >= CALLOUT_IDLE_TIME && !player1.isCallout && !player2.isCallout) {
                    player1.triggerCallout();
                    player2.triggerCallout();
                }
                
                // Detect if any action occurred this frame
                const anyMovement = player1.velocityX !== 0 || player1.velocityY !== 0 || 
                                   player2.velocityX !== 0 || player2.velocityY !== 0;
                const anyAttack = player1.attacking || player2.attacking;
                const anyBlock = player1.blocking || player2.blocking;
                
                if (anyMovement || anyAttack || anyBlock) {
                    resetActionTimer();
                }
                
                // Update fighters
                player1.update(player2);
                player2.update(player1);
                
                // Check collisions
                if (checkCollision(player1, player2)) {
                    let damage = 0;
                    if (player1.attackType === 'special') damage = 8;
                    else if (player1.attackType === 'punch') damage = 6;
                    else if (player1.attackType === 'kick') damage = 10;
                    
                    player2.takeDamage(damage, player2.blocking);
                    player1.attackBox.width = 0; // Hit detected, remove hitbox
                    resetActionTimer(); // Reset idle timer on hit
                    
                    if (player2.health <= 0) {
						// Player won the round!
						player1RoundWins++;
						console.log('Player wins round! Score:', player1RoundWins, '-', player2RoundWins);

						if (player1RoundWins >= 2) {
        					// WON THE MATCH! Show finisher
        					console.log('Player wins match! Starting finisher...');
        					gameOver = true;

							// Short delay, then start finisher
							setTimeout(() => {
								startFinisher();
							}, 1000);
						} else {
							// Won the round but not the match - start next round
							console.log('Starting next round...');
							currentRound++;
							gameOver = true;

							// Show round result
							const gameOverDiv = document.getElementById('gameOver');
							gameOverDiv.textContent = 'WINNER!';
							gameOverDiv.style.display = 'block';

							setTimeout(() => {
								startRound();
							}, 2000);
						}
					}
				}
                
                if (checkCollision(player2, player1)) {
                    let damage = 0;
                    if (player2.attackType === 'special') damage = 8;
                    else if (player2.attackType === 'puch') damage = 6;
                    else if (player2.attackType === 'kick') damage = 10;
                    
                    player1.takeDamage(damage, player1.blocking);
                    player2.attackBox.width = 0;
                    resetActionTimer(); // Reset idle timer on hit
                    
                    if (player1.health <= 0) {
						// AI won the round!
						player2RoundWins++;
						    console.log('AI wins round! Score:', player1RoundWins, '-', player2RoundWins);

						if (player2RoundWins >= 2) {
							// Lost the match - GAME OVER!

							console.log('AI wins match - Game Over!');
							gameOver = true;
							endGame();
						} else {
						// Lost the round but not the match - start next round
							console.log('Starting next round...');
							currentRound++;
							gameOver = true;

							// Show round result
							const gameOverDiv = document.getElementById('gameOver');
							gameOverDiv.textContent = 'LOSER!';
							gameOverDiv.style.display = 'block';

							setTimeout(() => {
								startRound();
							}, 2000);
						}
					}
				}
				
                // Update UI
                updateHealthBars();
            }
            
            // Draw fighters
            player1.draw();
            player2.draw();
            
            requestAnimationFrame(gameLoop);
        }
        
        function endGame() {
            const gameOverDiv = document.getElementById('gameOver');
            
            if (currentFight > 7 && player1.health > 0) {
                gameOverDiv.textContent = 'GAME COMPLETE!';
            } else if (player1.health <= 0) {
                gameOverDiv.textContent = 'YOU LOSE!';
            } else {
                gameOverDiv.textContent = 'VICTORY!';
            }
            
            gameOverDiv.style.display = 'block';
        }
        // Start game loop (but don't init yet - wait for button click)
		gameLoop();
    </script>
</body>
</html>
